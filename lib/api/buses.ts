import { supabase, Bus, BusStop, BusWithStops } from '@/lib/supabase';

export const busApi = {
    /**
     * Get all buses with their stops (for customers browsing)
     */
    async getAll(): Promise<BusWithStops[]> {
        const { data, error } = await supabase
            .from('buses')
            .select(`
                *,
                stops:bus_stops(*)
            `)
            .order('created_at', { ascending: false });

        if (error) throw error;
        return (data || []) as BusWithStops[];
    },

    /**
     * Get buses owned by a specific owner
     */
    async getByOwner(ownerId: string): Promise<BusWithStops[]> {
        const { data, error } = await supabase
            .from('buses')
            .select(`
                *,
                stops:bus_stops(*)
            `)
            .eq('owner_id', ownerId)
            .order('created_at', { ascending: false });

        if (error) throw error;
        return (data || []) as BusWithStops[];
    },

    /**
     * Get a single bus by ID with stops
     */
    async getById(busId: string): Promise<BusWithStops | null> {
        const { data, error } = await supabase
            .from('buses')
            .select(`
                *,
                stops:bus_stops(*)
            `)
            .eq('id', busId)
            .single();

        if (error) {
            if (error.code === 'PGRST116') return null; // Not found
            throw error;
        }
        return data as BusWithStops;
    },

    /**
     * Create a new bus
     */
    async create(bus: {
        owner_id: string;
        registration_number: string;
        route_from: string;
        route_to: string;
        total_seats?: number;
    }): Promise<Bus> {
        const { data, error } = await supabase
            .from('buses')
            .insert({
                ...bus,
                ref_number: '', // Will be auto-generated by trigger
            })
            .select()
            .single();

        if (error) throw error;
        return data as Bus;
    },

    /**
     * Update a bus
     */
    async update(id: string, updates: Partial<Bus>): Promise<Bus> {
        const { data, error } = await supabase
            .from('buses')
            .update(updates)
            .eq('id', id)
            .select()
            .single();

        if (error) throw error;
        return data as Bus;
    },

    /**
     * Delete a bus
     */
    async delete(id: string): Promise<void> {
        const { error } = await supabase
            .from('buses')
            .delete()
            .eq('id', id);

        if (error) throw error;
    },

    /**
     * Add a stop to a bus
     */
    async addStop(busId: string, stop: { name: string; arrival_time: string }): Promise<BusWithStops> {
        // Get current max sequence
        const { data: existingStops } = await supabase
            .from('bus_stops')
            .select('sequence')
            .eq('bus_id', busId)
            .order('sequence', { ascending: false })
            .limit(1);

        const nextSequence = (existingStops && existingStops.length > 0)
            ? existingStops[0].sequence + 1
            : 1;

        const { error } = await supabase
            .from('bus_stops')
            .insert({
                bus_id: busId,
                name: stop.name,
                arrival_time: stop.arrival_time,
                sequence: nextSequence,
            });

        if (error) throw error;

        // Return updated bus with stops
        return this.getById(busId) as Promise<BusWithStops>;
    },

    /**
     * Get stops for a bus (ordered by sequence)
     */
    async getStops(busId: string): Promise<BusStop[]> {
        const { data, error } = await supabase
            .from('bus_stops')
            .select('*')
            .eq('bus_id', busId)
            .order('sequence', { ascending: true });

        if (error) throw error;
        return (data || []) as BusStop[];
    },

    /**
     * Update all stops for a bus (replaces existing)
     */
    async updateStops(busId: string, stops: Omit<BusStop, 'id'>[]): Promise<BusStop[]> {
        // Delete existing stops
        const { error: deleteError } = await supabase
            .from('bus_stops')
            .delete()
            .eq('bus_id', busId);

        if (deleteError) throw deleteError;

        if (stops.length === 0) return [];

        // Insert new stops
        const { data, error } = await supabase
            .from('bus_stops')
            .insert(stops)
            .select();

        if (error) throw error;
        return (data || []) as BusStop[];
    },

    /**
     * Delete a specific stop and return updated bus
     */
    async deleteStop(busId: string, stopId: string): Promise<BusWithStops> {
        const { error } = await supabase
            .from('bus_stops')
            .delete()
            .eq('id', stopId);

        if (error) throw error;

        // Return updated bus with stops
        return this.getById(busId) as Promise<BusWithStops>;
    },

    /**
     * Update bus location (for real-time tracking)
     */
    async updateLocation(
        busId: string,
        location: {
            current_lat: number;
            current_lng: number;
            current_stop?: string;
            occupancy?: 'Low' | 'Medium' | 'High' | 'Full';
        }
    ): Promise<Bus> {
        const { data, error } = await supabase
            .from('buses')
            .update(location)
            .eq('id', busId)
            .select()
            .single();

        if (error) throw error;
        return data as Bus;
    },
};
